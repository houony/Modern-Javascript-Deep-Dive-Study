# 스프레드 연산자와 Rest 파라미터

자바스크립트 코드를 해석하다보면 … 으로 시작하는 코드가 자주 보인다. …은 자바스크립트에서 나머지 매개변수나 스프레드 문법으로 사용할 수 있다. 각각 어떤 상황에서 …이 사용되고 어떤 특징을 가지는지 살펴보자.

### 스프레드 연산자란?

> 하나로 뭉쳐있는 여러 값들의 집합을 펴려서 개별적인 값들의 목록으로 바꾸는 것
> 
- 스프레드 문법은 값이 아니다. 따라서 변수에 할당하면 에러가 발생한다.
    
    ```jsx
    const list = ...[1,2,3]; //SyntaxError
    ```
    

### 스프레드 문법은 언제 사용할 수 있는데?

- 함수 호출문의 인수 목록으로 사용될 수 있다.
    
    ```jsx
    const arr = [1,2,3];
    
    const minValue = Math.min(...arr);
    
    console.log(minValue); //1
    ```
    
- 배열 리터럴의 요소 목록으로 사용될 수 있다.
    - 여러 개의 배열을 한 개의 배열로 붙이고 싶을때 - concat
        
        ```jsx
        const arr = [...[1,2], ...[3,4]];
        console.log(arr); // [1, 2, 3, 4]
        ```
        
    - 배열의 중간에 다른 배열의 요소들을 추가하거나 제거하고싶을때 -  splice
        
        ```jsx
        var arr1 = [1,4];
        var arr2 = [2,3];
        
        arr1.splice(1, 0, ...arr2);
        
        console.log(arr1); // [1, 2, 3, 4]
        ```
        
    - 배열에 다른 배열을 - push
        
        ```jsx
        var arr1 = [1, 2];
        var arr2 = [3, 4];
        const arr3 = [5, 6];
        
        Array.prototype.push.apply(arr1, arr2); // arry1.push(arr2) 하면 배열 요소로 arr2가 들어가게 됨
        console.log(arr1); // [1, 2, 3, 4]
        
        // 스프레드 문법
        arr1.push(...arr3);
        console.log(arr1); // [1, 2, 3, 4, 5, 6]
        ```
        
    - 배열 복사 - slice
        
        ```jsx
        // 스프레드 문법
        const origin2 = ["면", "멸치육수"];
        const copy2 = [...origin2];
        
        console.log(copy2); // ['면', '멸치육수']
        ```
        
    - 유사 배열 객체를 배열로 변환
        
        ```jsx
        
        // 스프레드 문법
        function isRamen2() {
          var args = [...arguments];
        
          return args.some((item) => item === "스프");
        }
        
        console.log(isRamen2("면", "계란", "스프")); // true
        ```
        
- 객체 리터럴의 프로퍼티 목록으로 사용될 수 있다.
    
    ```jsx
    const merged = Object.assign({}, { x: 1, y: 2 },{ y: 10, z: 3});
    console.log(merged); // { x: 1, y: 10, z: 3}
    
    //스프레드 문법
    const merged = { ...{ x: 1, y: 2}, ...{ y: 10, z: 3 } };
    console.log(merged2);
    
    ```
    

### rest파라미터는 무엇인가?

- rest파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 …을 붙이는 것

```jsx
function foo(...rest) {
  console.log(Array.isArray(rest)); // true
  console.log(rest); // [ 1, 2, 3, 4, 5 ]
}

foo(1, 2, 3, 4, 5);
```

- 함수에 전달된 인수들은 순차적으로 파라미터와 Rest파미터에 할당된다.

```jsx
function foo(param, ...rest) {
  console.log(param); // 1
  console.log(rest);  // [ 2, 3, 4, 5 ]
}

foo(1, 2, 3, 4, 5);

function bar(param1, param2, ...rest) {
  console.log(param1); // 1
  console.log(param2); // 2
  console.log(rest);   // [ 3, 4, 5 ]
}

bar(1, 2, 3, 4, 5);
```

- rest 파라미터는 이름 그대로 먼저 선언된 파라미터에 할당된 인수를 제외한 나머지 인수들이 배열에 담겨 할당되므로 Rest파라미터는 반드시 마지막 파라미터야 한다.

### Rest 파라미터와 Spread 파라미터의 차이?

```jsx
// 객체 리터럴 Rest/Spread 프로퍼티
// Spread 프로퍼티
const n = { x: 1, y: 2, ...{ a: 3, b: 4 } };
console.log(n); // { x: 1, y: 2, a: 3, b: 4 }

// Rest 프로퍼티
const { x, y, ...z } = n;
console.log(x, y, z); // 1 2 { a: 3, b: 4 }
```

- Rest파라미터를 통해 가변 인자의 목록을 **배열**로 전달받을 수 있다.
- Spread문법은 대상을 개별 요소로 분리한다.

### 정리

Rest parameter가 이름을 배신하고 함수 인자가 아닌 곳에 사용되면 헷갈림을 유발할 수 있다. 간단한 예제를 보면 자신감이 충만하지만, 훨씬 복잡한 코드 중간에 삽입된 다수의 `...`들을 보면 해석이 어렵다. 이런 경우를 대비하여 이해에 도움을 주는 문장 몇 개를 기억하자.

- spread operator는 펼치고, rest parameter는 모은다.
- spread operator는 주는 쪽이고, rest parameter는 받는 쪽이다.
- spread operator는 기존의 변수를 사용하고, rest parameter는 새로운 변수를 만든다.

마지막으로 위 세가지 문장을 합쳐본다.

> spread operator는 기존의 변수를 펼쳐서 주는 쪽이고, rest parameter는 여러개의 인자를 받고 그것들을 합쳐서 새로운 배열/객체를 만든다.
> 

### 질문1

아래 코드의 실행 결과를 말하고 왜 이렇게 나오는지 말하시오

```jsx
const obj = { a: 1, b: 2, c: 3 }
const { c, ...obj2 } = obj 
```

- 정답
    - 이 문제는 객체 구조분해할당(Destructing Assignment) + Rest Properties(나머지 속성)에 대해 사용하는 예제
    - `{ c, ...obj2 }` 부분에서, 객체 `obj`의 `c` 속성을 추출하여 변수 `c`에 할당합니다. 결과적으로, `c`의 값은 `3`이 됩니다.
    - 나머지 속성(rest properties) 구문 `...obj2`은 `obj` 객체에서 남은 모든 속성을 새로운 객체 `obj2`에 할당합니다. 여기서 중요한 점은 `c` 속성은 이미 추출되었기 때문에 `obj2`에는 포함되지 않는다는 것입니다. 따라서, `obj2`는 `a`와 `b` 속성만 포함하는 새로운 객체가 됩니다.
    
    ![스크린샷 2024-08-06 오후 7.14.22.png](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%AA%20Rest%20%E1%84%91%E1%85%A1%E1%84%85%E1%85%A1%E1%84%86%E1%85%B5%E1%84%90%E1%85%A5%20394ff4dd047f444581f9c6074b3cc7ef/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-06_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.14.22.png)
    

### 질문 2

아래 코드의 실행 결과를 말하고 왜 이렇게 나오는지 말하시오

```jsx
const getUser = (emailIncluded) => {
  return {
    name: 'John',
    surname: 'Doe',
    ...emailIncluded && { email : 'john@doe.com' }
  }
}

const user = getUser(true);
console.log(user); 
```

- 정답
    
    ![스크린샷 2024-08-06 오후 7.22.52.png](%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%AA%20Rest%20%E1%84%91%E1%85%A1%E1%84%85%E1%85%A1%E1%84%86%E1%85%B5%E1%84%90%E1%85%A5%20394ff4dd047f444581f9c6074b3cc7ef/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-08-06_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.22.52.png)
    
    이 코드는 `emailIncluded`가 `true`라면 `email` key/value를 객체에 추가하고 `false`라면 추가하지 않도록 합니다. 
    
    여기서 주의해야 할 부분은 연산자 수행 순서입니다. `...` 연산자로 펼쳐진 다음 `&&`를 만나는 것이 아니라, `&&` 연산자로 AND 처리가 된 후에 그 결과에 대해 `...` 연산자로 펼쳐지는 것입니다. 연산자 우선 순위를 잘 모른다면 헷갈리는 코드가 되기 십상입니다. 
    
    제가 만약 이 코드를 프로덕션에 사용한다면 다음처럼 괄호를 포함하고 싶을 것 같습니다.
    
    ```jsx
    ...(emailIncluded && { email : 'john@doe.com' })
    ```
    

### 질문 3 프로그래머스 문제 변형

### **문제 설명**

배열 arr가 주어집니다.

- 배열의 크기는 0~9 사이의 숫자
- 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다.
- 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다.
- arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.
- arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.
- filter 메서드를 이용하여 한 줄의 코드로 만들어야 합니다.
- 현재 요소와 다음 요소를 비교하세요

배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.

### 제한사항

- 배열 arr의 크기 : 1,000,000 이하의 자연수
- 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수

---

### 입출력 예

| arr | answer |
| --- | --- |
| [1,1,3,3,0,1,1] | [1,3,0,1] |
| [4,4,4,3,3] | [4,3] |

```jsx
function solution(arr) {
	return 
}
```

- 정답
    
    배열 `arr`의 각 요소에 대해 다음과 같은 검사를 수행합니다:
    
    - 현재 요소(`val`)와 다음 요소(`arr[index+1]`)를 비교합니다.
    - 만약 현재 요소가 다음 요소와 다르면, 이 요소를 결과 배열에 포함시킵니다.
    - 만약 현재 요소가 다음 요소와 같으면, 이 요소는 결과 배열에 포함되지 않습니다.
    
    ### 예제
    
    ```jsx
    
    let arr = [1, 2, 2, 3, 4, 4, 5];
    let result = arr.filter((val, index) => val != arr[index+1]);
    console.log(result); // [1, 2, 3, 4, 5]
    ```
    
    ### 설명
    
    1. 배열 `arr`의 각 요소를 하나씩 살펴봅니다.
    2. 현재 요소 `val`과 그 다음 요소 `arr[index+1]`을 비교합니다.
    3. 만약 현재 요소 `val`이 다음 요소 `arr[index+1]`와 다르면, 이 요소를 결과 배열에 포함시킵니다.
    4. 만약 현재 요소 `val`이 다음 요소 `arr[index+1]`와 같으면, 이 요소는 결과 배열에 포함되지 않습니다.