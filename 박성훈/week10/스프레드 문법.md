35장 스프레드 문법
===
```
console.log(...[1, 2, 3]);  // 1 2 3
```
- 스프레드 문법 ... 은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다.
- 스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, Set, Dom 컬렉션, arguments과 같이 for ... of 문으로 순회할 수 있는 이터러블에 한정된다.
- 스프레드 문법의 결과는 값이 아니므로 변수에 할당할 수 없고, 다음과 같이 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다.
  - 함수 호출문의 인수 목록
  - 배열 리터럴의 요소 목록
  - 객체 리터럴의 프로퍼티 목록
 
함수 호출문의 인수 목록에서 사용하는 경우
---
```
Math.max(1, 2, 3);  //  3
Math.max([1, 2, 3]);  // NaN

Math.max(...[1, 2, 3]);  // 3
```
- 매개변수 개수를 확정할 수 없는 가변 인자 함수인 Math.max 메서드는 여러 개의 숫자를 인수로 받아 최대값을 반환한다.
- 숫자가 아닌 배열을 인수로 전달하면 NaN을 반환하지만, 배열을 펼쳐 요소들을 개별적인 값들의 목록으로 만들면 최대값을 반환한다.
- 스프레드 문법은 Rest 파라미터와 혼동할 수 있으므로 주의가 필요하다. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 매개변수 이름 앞에 ...을 붙이는 것이다. 스프레드 문법은 여러 개의 값이 하나로 뭉쳐 있는 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만드는 것이므로 서로 반대의 개념이다.

배열 리터럴 내부에서 사용하는 경우
---
- concat
  ```
  // ES5
  var arr = [1, 2].concat([3, 4]);  // [1, 2, 3, 4]

  // ES6
  const arr2 = [...[1, 2], ...[3, 4]];  // [1, 2, 3, 4]
  ```
  - 스프레드 문법을 사용하면 concat 메서드를 사용하지 않고 배열 리터럴만으로 2개의 배열을 1개의 배열로 결합할 수 있다.

- splice
  ```
  var arr1 = [1, 4];
  var arr2 = [2, 3];

  arr1.splice(1, 0, arr2);  // [1, [2, 3], 4]
  Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));  // [1, 2, 3, 4]
  arr1.splice(1, 0, ...arr2);  // [1, 2, 3, 4]
  ```
  - 어떤 배열의 중간에 다른 배열의 요소들을 추가하거나 제거할 때 사용하는 splice 메서드의 세 번째 인수로 배열을 전달하면 배열 자체가 추가된다.
  - Function.prototype.apply 메서드를 사용하여 splice 메서드를 호출하고, apply 메서드의 두 번째 인수로 전달한 배열은 해체되어 전달된다.
  - 이를 스프레드 문법을 사용하면 더욱 간결하고 가독성 좋게 표현할 수 있다.

- 배열 복사
  ```
  // ES5
  var origin = [1, 2];
  var copy = origin.slice();

  // ES6
  const origin2 = [1, 2];
  const copy2 = [...origin];
  ```
  - 배열을 복사할 때 사용하는 slice 메서드 대신 스프레드 문법을 사용하여 slice와 마찬가지로 원본 배열을 얕은 복사하여 새로운 복사본을 생성할 수 있다.

- 이터러블을 배열로 변환
  ```
  // ES5
  function sum() {
    var args = Array.prototype.slice.call(arguments);

    return args.reduce(function (pre, cur) {
      return pre + cur;
    }, 0);
  }

  console.log(sum(1, 2, 3));  // 6

  // ES6
  function sum2() {
    return [...arguments].reduce((pre, cur) => pre + cur, 0);
  }

  console.log(sum2(1, 2, 3));  // 6

  const sum3 = (...args) => args.reduce((pre, cur) => pre + cur, 0);

  console.log(sum3(1, 2, 3));  // 6
  ```
  - ES5에서 이터러블을 배열로 변환하려면 Function.prototype.apply 또는 Function.prototype.call 메서드를 사용하여 slice 메서드를 호출해야 한다. 이는 이터러블이 아닌 유사 배열 객체도 배열로 변환할 수 있다.
  - 스프레드 문법, Rest 파라미터를 사용하면 더 간편하게 이터러블을 배열로 변환할 수 있다. 그러나 이터러블이 아닌 유사 배열 객체는 변환할 수 없다.

객체 리터럴 내부에서 사용하는 경우
---
```
const obj = { x: 1, y: 2 };
const copy = { ...obj };

const merged = Object.assing({}, { x: 1, y: 2 }, { y: 10, z: 3 });  // { x: 1, y: 10, z: 3 }
const merged2 = { x: 1, y: 2, ...{ a: 3, b: 4 } };  // { x: 1, y: 2, a: 3, b: 4 }
```
- TC39 프로세스의 stage 4 단계에 제안되어 있는 스프레드 프로퍼티를 사용하면 객체 리터럴의 프로퍼티 목록에서도 스프레드 문법을 사용할 수 있다.
- 스프레드 문법의 대상은 이터러블이어야 하지만 스프레트 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다.
- 스프레드 프로퍼티가 제안되기 이전에는 Object.assing 메서드를 사용해 여러 개의 객체를 병합하거나 특정 프로퍼티를 변경/추가했다. 스프레드 프로퍼티를 사용해 이를 간편하게 대체할 수 있다.

