876 ~ 901
https://velog.io/@qkrtofha94/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Deep-Dive-45%EC%9E%A5-%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4

45장 프로미스
===

비동기 처리를 위한 콜백 패턴의 단점
---
- 콜벡 핼
  ```
  const get = (url, callback) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.send();
  
    xhr.onload = () => {
      if (xhr.status === 200) {
        callback(JSON.parse(xhr.response));
      }else{
        console.error(`${xhr.status}`);
      }
    };
  };
  
  const url = "https://json~~";
  
  // userId 취득
  get(`${url}/posts/1`, ({userId}) => {
  	console.log(userId);
    	// userId를 사용해 user 정보 취득
    	get(`${url}/posts/${userId}`, userInfo => {
      	console.log(userInfo);
      })
  });
  ```
  - 비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않아도 즉시 종료된다. 따라서 해당 코드의 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한대로 동작하지 않는다.
  - 비동기 함수인 타이머 함수의 콜백 함수에서 값을 반환하는 것은 무의미하다.
  - GET 함수 내부의 onload 이벤트 핸들러가 비동기로 동작하기 때문에 get 함수는 비동기 함수다.

- 비동기 처리를 위한 콜백 패턴은 콜백 헬이나 에러 처리가 곤란하다는 문제가 있다. 이를 극복하기 위해 ES6에서 프로미스가 도입되었다.
    - 콜백 헬: 콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또다시 비동기 함수를 호출할 때 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상
    - 에러 처리 문제: try 코드 블록 내에서 호출한 비동기 함수의 콜백 함수가 에러를 발생시켜도 비동기 함수는 콜백 함수가 에러를 일으키기 전에 종료되기 때문에 catch 코드 블록에 캐치되지 않는다.

프로미스의 생성
---
- Promise 생성자 함수는 new 연산자와 함께 호출하면 프로미스 객체를 생성한다.
- Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수인 resolve와 reject를 인수로 전달받는다.
- 비동기 처리 성공 시 resolve 함수 호출, 실패 시 reject 함수를 호출한다.
- 프로미스는 비동기 처리가 어떻게 진행되고 있는지를 나타내는 상태 정보를 갖는다.
- ![image](https://github.com/user-attachments/assets/0cccc37e-9ba0-4670-ad6c-ae5eeaf0e22a)
- 생성된 직후의 프로미스는 기본적으로 pending 상태이고 비동기 처리 결과에 따라 프로미스의 상태가 변경된다.
- fulfilled 또는 rejected 상태를 settled 상태라고 한다.(성공/실패 여부와 상관없이 비동기 처리가 수행된 상태)
- ![image](https://github.com/user-attachments/assets/779662f5-f406-4b1d-86c7-d0db8b2a8b1a)
- 프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체다.

프로미스의 후속 처리 메서드
---
- 프로미스의 비동기 처리 상태가 변화하면 이에 따른 후속 처리를 해야 한다,
- 이를 위해 프로미스는 후속 메서드 then, catch, finally를 제공한다.
- 프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다.

- Promise.prototype.then
  - then 메서드는 2개의 콜백 함수를 인수로 전달받는다.
  - fulfilled 상태일 때 호출되는 콜백 함수 -> 성공 처리 콜백 함수
  - rejected 상태일 때 호출되는 콜백 함수 -> 실패 처리 콜백 함수
  - then 메서드는 언제나 프로미스를 반환한다. then 메서드의 콜백 함수가 프로미스를 반환하면 그대로, 프로미스가 아닌 값을 반환하면 그 값을 암묵적으로 resolve 또는 reject하여 프로미스 생성해 반환한다.
  ```
  new Promise(resolve => resolve('fulfilled'))
  	.then(v => console.log(v), e => console.error(e))
  ```
- Promise.prototype.catch
  - catch 메서드는 1개의 콜백 함수를 인수로 전달받는다.
  - catch 메서드의 콜백 함수는 프로미스가 rejected 상태인 경우에만 호출된다.
  - then 메서드와 동일하게 동작한다.
  ```
  new Promise(resolve => reject(new Error('rejected')))
  	.catch(e => console.log(e))
  ```
- Promise.prototype.finally
  - finally 메서드는 1개의 콜백 함수를 인수로 전달받는다.
  - finally 메서드의 콜백 함수는 프로미스의 성공 또는 실패와 상관없이 무조건 1번 호출된다.
  - finally 메서드는 프로미스의 상태와 상관없이 공통적으로 수행해야 할 처리 내용이 있을 때 유용하다.
  - then, catch 메서드와 동일하게 동작한다.
  ```
  new Promise(() => {})
  	.finally(() => console.log('finally'))
  ```

프로미스의 에러 처리
---
- 비동기 처리에서 발생한 에러는
- then 메서드의 두 번째 콜백 함수로 처리할 수 있다.
  ```
  promiseGet(wrongUrl).then(
    res => console.log(res),
    err => console.error(err)
  );
  ```
- 혹은, 프로미스의 후속 처리 메서드 catch를 사용해 처리할 수도 있다.
  ```
  promiseGet(wrongUrl)
    .then(res => console.log(res))
    .catch(err => console.error(err));
  ```
- then 방법보다 catch 방법이 가독성이 좋고 명확하기 때문에 catch 메서드를 사용하는 것을 권장한다.










