27장 배열
===

배열이란?
---
```
const arr = ['apple', 'banana', 'orange']
```
- 배열은 여러 개의 값을 순차적으로 나열한 자료구조다.
- 배열이 가지고 있는 값을 요소(element)라고 부르고 모든 값은 요소가 될 수 있다.
- 요소는 자신의 위치를 나타내는 0 이상의 정수인 인덱스(index)를 갖는다.
- 배열은 요소의 개수, 배열의 길이를 나타내는 length 프로퍼티를 갖는다.
  - 인덱스와 length 프로퍼티를 갖기 때문에 for 문을 통해 순차적으로 요소에 접근할 수 있다.
    ```
    for (let i=0; i<arr.length; i++) {
      console.log(arr[i]);
    );
    // 'apple', 'banana', 'orange'
    ```
- 배열은 배열 리터럴, Array 생성자 함수, Array.of, Array.from 메서드로 생성할 수 있다. 배욜의 생성자 함수는 Array이며, 배열의 프로토타입 객체는 Array.prototype이다. Array.prototype은 배열을 위한 빌트인 메서드를 제공한다.
  ```
  const arr = [1,2,3];
  arr.constructor === Array // true
  Object.getPrototypeOf(arr) === Array.prototype // true
  ```
- 배열과 일반 객체의 차이
  ![image](https://github.com/user-attachments/assets/4113ec06-fd9c-42df-818f-2dfd96e6cf6d)
  - 인덱스로 표현되는 값의 순서와 length 프로퍼티를 갖는 배열은 반복문을 통해 순차적으로 값에 접근하기 적합한 자료구조다.

자바스크립트 배열은 배열이 아니다
---
- 자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조를 말한다. 배열의 요소는 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이러한 배열을 밀집 배열이라 한다.
- 이런 경우 인덱스를 통해 매우 효율적이고 빠른 단 한 번의 연산으로 임의의 요소에 접근(O(1))할 수 있다.
- 그러나 정렬되지 않은 배열에서 검색하는 경우 처음부터 발견할 때까지 검색(O(n))해야 한다. 그리고 배열에 요소를 삽입/삭제하는 경우 요소를 연속적으로 유지하기 위해 요소를 이동시켜야 하는 단점도 있다.
- JS의 배열은 위와 달리, 배열의 요소를 위한 각각의 메모리 공간이 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 이렇게 요소가 연속적이지 않은 배열을 희소 배열이라 한다.
- 따라서 JS의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다.
- JS 배열은 인덱스를 나타내는 문자열을 프로퍼티 키로 가지며 length 프로퍼티를 갖는다. 배열의 요소는 프로퍼티 값이고, JS의 모든 값은 객체의 프로퍼티 값이 될 수 있으므로 어떤 값이라도 배열의 요소가 될 수 있다.
- JS 배열은 일반 배열보다 성능적인 면에서 느릴 수 있으나, 특정 요소를 검색, 삽입, 삭제하는 경우에는 일반 배열보다 빠른 성능을 기대할 수 있다.

length 프로퍼티와 희소 배열
---
- length 프로퍼티는 요소의 개수를 나타내는 0 이상의 정수(0과 2^32 - 1 미만의 양의 정수)를 값으로 갖는다.
- length 프로퍼티 값은 요소를 추가하거나 삭제하면 자동 갱신된다.
- length 프로퍼티 값에 임의의 숫자 값을 명시적으로 할당할 수 있고, 현재 length 프로퍼티 값보다 작은 숫자 값을 할당하면 배열의 길이가 줄어든다.
- 더 큰 값을 할당하는 경우 length 프로퍼티 값은 변경되지만 실제 배열의 길이가 늘어나지는 않는다. 값 없이 비어있는 요소를 위해 메모리 공간을 확보하지 않고 빈 요소를 생성하지도 않는다.
- 배열의 요소가 연속적으로 위치하지 않고 일부가 비어있는 배열을 희소 배열이라고 한다.
- 희소 배열의 length 프로퍼티 값은 요소 개수와 일치하지 않는다. 희소 배열의 length는 언제나 실제 요소 개수보다 크다.
- JS 엔진은 일반 배열처럼 연속된 메모리 공간을 확보하므로, 배열에 같은 타입의 요소를 연속적으로 위치시키며 희소 배열을 생성하지 않도록 주의해야 한다.

배열 생성
---
- 배열 리터럴
```
const arr = [1, 2, 3];
cosnt arr2 = []; // 빈 배열
const arr3 = [1, , 3]; //희소 배열
console.log(arr3[1]); // undefined
```
  - 배열 리터럴은 0개 이상의 요소를 쉼표로 구분하여 대괄호로 묶는다. 배열 리터럴을 객체 리터럴과 달리 프로퍼티 키가 없고 값만 존재한다.
- Array 생성자 함수
```
cosnt arr = new Array(); // []
const arr2 = new Array(10); // length 프로퍼티 값이 10인 희소 배열
const arr3 = new Array(1, 2, 3); // [1, 2, 3]
const arr4 = new Array({}); // [{}]
```
  - Array 생성자 함수는 전달된 인수의 개수에 따라 다르게 동작한다.
    - 인수 0개 : 빈 배열 생성
    - 인수 1개 : length 프로퍼티 값에 전달된다. 전달된 인수가 0~4,294,967,295를 벗어나면 RangeError가 발생한다.
    - 인수 2개 or 숫자가 아닌 경우 : 전달된 인수를 요소로 갖는 배열 생성
- Array.of
```
Array.of(1); // [1]
Array.of(1, 2, 3); // [1, 2, 3]
Array.of('string;); // ['string']
```
  - Array.of 메서드는 전달된 인수를 요소로 갖는 배열을 생성한다.
- Array.from
'''
Array.from({ length: 2, 0: 'a', 1: 'b' }); // ['a', 'b']
Array.from('Hello'); // ['H', 'e', 'l', 'l', 'o']
Array.from({length: 3}, (_, i) => i); // [0, 1, 2]
'''
  -  Array.from 메서드는 유사 배열 객체 또는 이터러블 객체를 인수로 전닯다아 배열로 변환하여 반환한다.
  -  Array.from 메서드는 두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다.

배열 요소의 참조
---
- 









