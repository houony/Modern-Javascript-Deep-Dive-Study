Q 1. 아래 코드를 실행했을 때 `arr`와 `arr.length`의 값은 무엇인가? 그 이유는?

```jsx
const arr = [1, 2, 3];
arr[5] = 6;

console.log(arr); // ?
console.log(arr.length); // ?
```

A 1.

- `arr = [1, 2, 3, empty * 2, 6]`
- `arr.length = 6`
- length 프로퍼티 값보다 더 큰 임의의 숫자 값을 명시적으로 할당하면 length 프로퍼티 값은 변경되지만 실제 배열의 길이가 늘어나지는 않는다. 중간에 값 없이 비어있는 요소가 생기며 희소 배열이 된다.

Q 2. `target.match(regExp)`의 결과는 무엇인가?

```jsx
const target = 'A AA B BB Aa Bb AAA';
const regExp = /A{1, 2}/g;
console.log(target.match(regExp));
```

A 2. 

- SyntaxError: Invalid regular expression: /A{1, 2}/: `{1, 2}`: invalid range
- `["A", "AA", "A", "A", "A"]`
- `A`가 1번 이상 2번 이하 반복되는 문자열을 전역 검색한다.

Q 3. `for ... of 문`이 동작하는 방식을 설명해라. 내부적으로 어떤 메서드를 호출하며, 그 결과는 어떻게 처리되는가?
A 3.

- `for ... of 문`은 이터러블을 순회하면서 이터러블의 요소를 변수에 할당한다.
- 내부적으로 이터레이터의 `next` 메서드를 호출해 이터러블을 순회하며, next가 반환한 이터레이터 리절트 객체의 `value` 값을 `for ... of 문`의 변수에 할당한다.
- 그리고 `done` 값이 false면 계속 순회하고 true면 순회를 멈춘다.










Q 1. `filter` 메서드가 어떤 역할을 하는지 설명하고, `odds`의 값은 무엇인가?

```jsx
const numbers = [1, 2, 3, 4, 5];
const odds = numbers.filter(item => item % 2);
```

A 1.

- `filter` 메서드는 배열의 각 요소에 대해 주어진 콜백 함수를 실행하고, 콜백 함수가 `true`를 반환하는 요소들로 새로운 배열을 만든다.
- `odds`의 값은 `[1, 3, 5]`다. 콜백 함수 `item => item % 2`는 홀수를 `true`로 반환하므로, 배열에서 홀수만 필터링된다.

Q 2. `target.match(regExp)`의 결과는 무엇인가?

```jsx
const target = 'ABC123';
const regExp = /[^A-Za-z]/g;
console.log(target.match(regExp));
```

A 2.

- `["1", "2", "3"]`
- `[^A-Za-z]`는 알파벳이 아닌 문자열을 전역 검색한다.

Q 3. 다음 코드의 실행 결과를 예상해라.

```jsx
const arr = [10, 20, 30];
const iterator = arr[Symbol.iterator]();

console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
```

A 3.

```jsx
// { value: 10, done: false }
// { value: 20, done: false }
// { value: 30, done: false }
// { value: undefined, done: true }
```

- iterator는 `next` 메서드를 호출할 때마다 배열 arr의 각 요소를 순차적으로 반환한다. 마지막 호출에서는 더 이상 순회할 요소가 없으므로 `value`는 undefined, `done`은 true를 반환한다.

Q 1. `concat` 메서드와 스프레드 문법의 차이점을 설명하고, `arr2`와 `arr3`의 결과값은 각각 무엇인가?

```jsx
const arr1 = [1, 2, 3];
const arr2 = arr1.concat([4, 5]);
const arr3 = [...arr1, 4, 5];
```

A 1.

- `concat` 메서드는 기존 배열을 변경하지 않고, 주어진 배열이나 값을 기존 배열에 합쳐 새로운 배열을 반환한다.
- 스프레드 문법 `[...]`은 배열의 요소를 펼쳐서 새로운 배열을 만든다.
- `arr2`와 `arr3`의 값은 모두 `[1, 2, 3, 4, 5]`다.

Q 2. `regExp.test(target)`의 결과는 무엇인가?

```jsx
const target = 'abc#123';
const regExp = /[^A-Za-z0-9]/g;
console.log(regExp.test(target));
```

A 2. 

- `true`
- `[^A-Za-z0-9]`는 알파벳과 숫자가 아닌 문자가 포함되어 있는지 검사한다. `#`이 포함되어 있으므로 `true`를 반환한다.

Q 3. 유사 배열 객체와 이터러블의 차이점은 무엇인가?

A 3.

- 유사 배열 객체는 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.
- 이터러블은 Symbol.iterator 메서드를 가지고 있어야 하며, 이 메서드는 이터레이터를 반환한다.
- 이터러블은 for ... of 문으로 순회할 수 있지만, 일반 객체는 이터러블이 아니므로 for ... of 문으로 순회할 수 없고 for 문으로는 순회할 수 있다.
