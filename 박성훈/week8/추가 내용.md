클래스의 호이스팅, 함수 선언문으로 정의된 생성자 함수의 함수 호이스팅, 함수 표현식으로 정의한 생성자 함수의 변수 호이스팅
---
1. 클래스 호이스팅
```
const instance = new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {
  constructor() {
    this.name = 'example';
  }
}
```
- 스코프의 최상단으로 호이스팅되지만, 선언문 이전에 일시적 사각지대에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.
  
2. 함수 선언문으로 정의된 생성자 함수의 함수 호이스팅
```
const instance = new MyConstructor(); // 정상 동작

function MyConstructor() {
  this.name = 'example';
}
```
- 스코프의 최상단으로 호이스팅되고, 초기화도 동시에 이루어지므로 함수 정의 이전에 호출이 가능하다.

3. 함수 표현식으로 정의한 생성자 함수의 변수 호이스팅
```
const instance = new MyConstructor(); // TypeError: MyConstructor is not a constructor

var MyConstructor = function() {
  this.name = 'example';
};
```
- 변수의 초기화는 선언 위치에서 이루어지므로 선언문 이전에 호출할 수 없다.

1번과 3번의 차이점?
- 클래스 선언의 호이스팅
  - 클래스 선언 자체는 호이스팅되지만 초기화되지 않은 상태다.
  - 클래스는 호이스팅되어 스코프의 최상단에 존재하지만, 실제 초기화는 선언 위치에서 이루어지므로 일시적 사각지대에서 접근 시 ReferenceError가 발생한다.
- 함수 표현식으로 정의한 생성자 함수의 변수 호이스팅
  - 변수 호이스팅만 발생, 변수의 초기화는 선언 위치에서 이루어지므로 함수 정의 이전에 변수가 undefined 상태다.
  - 변수 선언만 호이스팅되어 스코프의 최상단에 존재하지만, 초기화가 선언 위치에서 이루어지므로 초기화 이전에 접근 시 TypeError가 발생한다.


유틸리티 함수
---
- 자주 사용되는 반복적인 작업을 간단하게 수행할 수 있도록 돕는 재사용 가능한 함수
- 코드 가독성 향상, 유지보수 용이
- 특징
  1. 재사용성: 여러 코드에서 반복적으로 사용될 수 있도록 설계된다.
  2. 단일 책임 원칙: 하나의 기능을 수행하도록 설계된다.
  3. 단순성: 간단한 작업을 쉽게 수행할 수 있도록 도와준다.


callable과 constructor / non-constructor
---
1. callable
- 호출할 수 있는 함수 객체, 프로퍼티와 메서드를 가질 수 있다.
2. constructor
- 객체를 초기화하는데 사용되는 함수 객체, new 키워드를 사용하여 호출될 때 constructor 역할을 할 수 있고, 인스턴스를 생성할 수 있다.
- ex) 함수 선언문, 함수 표현식, 클래스
3. non-constructor
- new 키워드 없이 호출되는 함수 객체, 인스턴스를 생성할 수 없고 내부 메서드 [[construct]]를 갖지 않는다. 생성자 함수로서 호출하면 에러가 발생한다.
- ex) 메서드 축약 표현으로 정의된 함수(메서드), 화살표 함수
```
function foo() {}

// 일반 함수로서 호출
// [[Call]]이 호출된다. 모든 함수 객체는 [[Call]]이 구현되어 있다.
foo();

// 생성자 함수로서 호출
// [[Construct]]가 호출된다. 이때 [[Construct]]를 갖지 않는다면 에러가 발생한다,
new foo();
```
