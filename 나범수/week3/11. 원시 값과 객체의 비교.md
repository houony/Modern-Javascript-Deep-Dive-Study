# 원시 값과 객체의 비교

태그: 11장

# 원시 값

---

## 변경 불가능한 값

**원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다.** 

```jsx
const o = {};
o.a = 1;
console.log(o); //{ a: 1 }
```

const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 상수는 재할당이 금지된 변수일 뿐이다.

**변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.**

```jsx
const o = {};

o.a = 1;
console.log(o); //{ a: 1 }
```

⇒ const 키워드를 사용해 선언한 변수는 재할당이 금지도니다.  상수는 재할당이 금지된 변수일 뿐이다.

하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.

## 문자열과 불변성

1개의 문자는 2바이트의 메모리 공간에 저장된다. 따라서 문자열은 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다. 
숫자 값은 1도, 100000도 동일한 8바이트가 필요하다.

문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

자바에서는 문자열을 String객체로 처리하지만 자바스크립트는 개발자의 편의를 위해 원시 타입인 문자열 타입을 제공한다. 이는 원시타입이며 변경 불가능하다.

---

```jsx
var str = "string";
str[0] = "S";
console.log(str); //string
```

str[0] = “S”처럼 이미 생성된 문자열의 일부 무자를 변경해도 반영되지 않는다. 문자열은 변경 불가능한 겂이기 때문이다.

원시 값은 어떤 일이 있어도 불변한다.

## 값에 의한 전달

```jsx
var score = 80;
var copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true

score = 100;

console.log(score, copy); // 100 80
console.log(score === copy); // false
```

변수 score와 copy 주소가 다르더라도 === 연산자가 true 를 반환하는 이유는, 자바스크립트에서 원시 타입 변수는 값 자체를 비교하기 때문이다

자바스크립트에서 원시 타입 변수는 메모리 주소가 아닌 값을 저장한다. 때문에 copy, score의 메모리 할당 주소가 달라고 === 연산자는 true를 반환한다.

```jsx
var score = 80;
var copy = 80;

console.log(score, copy); // 80 80
console.log(score === copy); // true
```

때문에 위의 경우에도 ===연산자는 true를 반환한다.

# 객체

---

객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다. 또한 프로퍼티의 값에도 제약이 없다.

## 변경 가능한 값

객체 타입의 값, 즉 객체는 변경 가능한 값이다.

원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 접근할 수 있다. 메모리 공간에 접근하면 참조 값에 접근할 수 있다.

```jsx
const v = 1;
// " 깊은 복사"라고부 르기도 한다.
const c1 = v;
console.log(c1 === v); //true
const o = { x: 1 };
// "얕은복사"라고부르기도한다.
const c2 = 0;
console.log(c2 === 0); // true
```

## 참조에 의한 전달

객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사되어** 전달된다. 이를 참조에 의한 전달이라고 한다.

![Untitled](%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%20310ceeeb976b498daf54871e54a7a899/Untitled.png)

결국 “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일한다. 

⇒ 자바스크립트에는 “참조에 의한 전달”은 존재하지 않고 “값에 의한 전달”만이 존재한다고 말할 수 있다.

```jsx
var person1 = {
  name: "Lee",
};
var person2 = {
  name: "Lee",
};
console.log(person1 === person2); //1
console.log(person1.name === person2.name); //2

```

=== 일치 비교 연산자는 변수에 저장되어 있는 값을 타입 변환하지 않고 비교한다.

객체 리터럴은 평가될 때 마다 객체를 생성한다. 따라서 person1 변수와 person2변수가 가르키는 객체는 비록 내용은 같지만 다른 메모리에 저장된 별개의 객체다. 

→ 즉 person1 변수와 person2 변수의 참조 값은 전혀 다른 값이다. 따라서 1은 false다.

하지만 프로퍼티 값을 참조하는 person1.name과 person2.name은 값으로 평가될 수 있는 표현식이다. 두 표현식 모두 원시 값 “Lee”로 평가된다.

→ 2는 true다.